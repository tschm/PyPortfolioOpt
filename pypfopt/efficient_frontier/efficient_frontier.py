"""
The ``efficient_frontier`` submodule houses the EfficientFrontier class.

This submodule generates classical mean-variance optimal portfolios for a
variety of objectives and constraints.
"""

import warnings

import cvxpy as cp
import numpy as np
import pandas as pd

from .. import base_optimizer, exceptions, objective_functions


class EfficientFrontier(base_optimizer.BaseConvexOptimizer):
    """
    Generate optimal portfolios along the mean-variance efficient frontier.

    An EfficientFrontier object (inheriting from BaseConvexOptimizer) contains
    multiple optimization methods that can be called (corresponding to different
    objective functions) with various parameters.

    Note: a new EfficientFrontier object should be instantiated if you want to
    make any change to objectives/constraints/bounds/parameters.

    Attributes
    ----------
    n_assets : int
        Number of assets in the portfolio.
    tickers : list
        List of asset tickers/identifiers.
    bounds : tuple or list
        Weight bounds for each asset.
    cov_matrix : np.ndarray
        Covariance matrix of asset returns.
    expected_returns : np.ndarray
        Expected returns for each asset.
    solver : str
        CVXPY solver name.
    solver_options : dict
        Solver parameters.
    weights : np.ndarray
        Optimized portfolio weights.

    Examples
    --------
    >>> import pandas as pd
    >>> from pypfopt import EfficientFrontier, expected_returns, risk_models
    >>> # prices = pd.read_csv("stock_prices.csv", index_col="date", parse_dates=True)
    >>> # mu = expected_returns.mean_historical_return(prices)
    >>> # S = risk_models.sample_cov(prices)
    >>> # ef = EfficientFrontier(mu, S)
    >>> # weights = ef.max_sharpe()
    """

    def __init__(
        self,
        expected_returns,
        cov_matrix,
        weight_bounds=(0, 1),
        solver=None,
        verbose=False,
        solver_options=None,
    ):
        """
        Initialize the EfficientFrontier object.

        Parameters
        ----------
        expected_returns : pd.Series, list, or np.ndarray
            Expected returns for each asset. Can be None if optimising
            for volatility only (but not recommended).
        cov_matrix : pd.DataFrame or np.ndarray
            Covariance of returns for each asset. This **must** be positive
            semidefinite, otherwise optimization will fail.
        weight_bounds : tuple or list, optional
            Minimum and maximum weight of each asset OR single min/max pair
            if all identical. Defaults to (0, 1). Must be changed to (-1, 1)
            for portfolios with shorting.
        solver : str, optional
            Name of solver. List available solvers with ``cvxpy.installed_solvers()``.
        verbose : bool, optional
            Whether performance and debugging info should be printed.
            Defaults to False.
        solver_options : dict, optional
            Parameters for the given solver.

        Raises
        ------
        TypeError
            If ``expected_returns`` is not a series, list or array.
            If ``cov_matrix`` is not a dataframe or array.
        ValueError
            If ``cov_matrix`` dimensions don't match ``expected_returns``.
        """
        # Inputs
        self.cov_matrix = self._validate_cov_matrix(cov_matrix)
        self.expected_returns = self._validate_expected_returns(expected_returns)
        self._max_return_value = None
        self._market_neutral = None

        if self.expected_returns is None:
            num_assets = len(cov_matrix)
        else:
            num_assets = len(expected_returns)

        # Labels
        if isinstance(expected_returns, pd.Series):
            tickers = list(expected_returns.index)
        elif isinstance(cov_matrix, pd.DataFrame):
            tickers = list(cov_matrix.columns)
        else:  # use integer labels
            tickers = list(range(num_assets))

        if expected_returns is not None and cov_matrix is not None:
            if cov_matrix.shape != (num_assets, num_assets):
                raise ValueError("Covariance matrix does not match expected returns")

        super().__init__(
            len(tickers),
            tickers,
            weight_bounds,
            solver=solver,
            verbose=verbose,
            solver_options=solver_options,
        )

    @staticmethod
    def _validate_expected_returns(expected_returns):
        """
        Validate and convert expected returns to numpy array.

        Parameters
        ----------
        expected_returns : pd.Series, list, np.ndarray, or None
            Expected returns for each asset.

        Returns
        -------
        np.ndarray or None
            Validated expected returns as a numpy array, or None.

        Raises
        ------
        TypeError
            If expected_returns is not a series, list or array.
        """
        if expected_returns is None:
            return None
        elif isinstance(expected_returns, pd.Series):
            return expected_returns.values
        elif isinstance(expected_returns, list):
            return np.array(expected_returns)
        elif isinstance(expected_returns, np.ndarray):
            return expected_returns.ravel()
        else:
            raise TypeError("expected_returns is not a series, list or array")

    @staticmethod
    def _validate_cov_matrix(cov_matrix):
        """
        Validate and convert covariance matrix to numpy array.

        Parameters
        ----------
        cov_matrix : pd.DataFrame or np.ndarray
            Covariance matrix of asset returns.

        Returns
        -------
        np.ndarray
            Validated covariance matrix as a numpy array.

        Raises
        ------
        ValueError
            If cov_matrix is None.
        TypeError
            If cov_matrix is not a dataframe or array.
        """
        if cov_matrix is None:
            raise ValueError("cov_matrix must be provided")
        elif isinstance(cov_matrix, pd.DataFrame):
            return cov_matrix.values
        elif isinstance(cov_matrix, np.ndarray):
            return cov_matrix
        else:
            raise TypeError("cov_matrix is not a dataframe or array")

    def _validate_returns(self, returns):
        """
        Validate daily returns data.

        Helper method to validate daily returns (needed for some efficient frontiers).

        Parameters
        ----------
        returns : pd.DataFrame or np.ndarray
            Historical daily returns.

        Returns
        -------
        pd.DataFrame
            Validated returns as a DataFrame with NaNs removed.

        Raises
        ------
        TypeError
            If returns is not a DataFrame or ndarray.
        ValueError
            If returns columns don't match expected returns.
        """
        if not isinstance(returns, (pd.DataFrame, np.ndarray)):
            raise TypeError("returns should be a pd.DataFrame or np.ndarray")

        returns_df = pd.DataFrame(returns)
        if returns_df.isnull().values.any():
            warnings.warn(
                "Removing NaNs from returns",
                UserWarning,
            )
            returns_df = returns_df.dropna(axis=0, how="any")

        if self.expected_returns is not None:
            if returns_df.shape[1] != len(self.expected_returns):
                raise ValueError(
                    "returns columns do not match expected_returns. Please check your tickers."
                )

        return returns_df

    def _make_weight_sum_constraint(self, is_market_neutral):
        """
        Create the weight sum constraint.

        Helper method to make the weight sum constraint. If market neutral,
        validate the weights provided in the constructor.

        Parameters
        ----------
        is_market_neutral : bool
            Whether the portfolio should be market neutral.
        """
        if is_market_neutral:
            # Check and fix bounds
            portfolio_possible = np.any(self._lower_bounds < 0)
            if not portfolio_possible:
                warnings.warn(
                    "Market neutrality requires shorting - bounds have been amended",
                    RuntimeWarning,
                )
                self._map_bounds_to_constraints((-1, 1))
                # Delete original constraints
                del self._constraints[0]
                del self._constraints[0]

            self.add_constraint(lambda w: cp.sum(w) == 0)
        else:
            self.add_constraint(lambda w: cp.sum(w) == 1)
        self._market_neutral = is_market_neutral

    def min_volatility(self):
        """
        Minimise portfolio volatility.

        Returns
        -------
        OrderedDict
            Asset weights for the volatility-minimising portfolio.

        Examples
        --------
        >>> from pypfopt import EfficientFrontier, expected_returns, risk_models
        >>> # mu = expected_returns.mean_historical_return(prices)
        >>> # S = risk_models.sample_cov(prices)
        >>> # ef = EfficientFrontier(mu, S)
        >>> # weights = ef.min_volatility()
        """
        self._objective = objective_functions.portfolio_variance(
            self._w, self.cov_matrix
        )
        for obj in self._additional_objectives:
            self._objective += obj

        self.add_constraint(lambda w: cp.sum(w) == 1)
        return self._solve_cvxpy_opt_problem()

    def _max_return(self, return_value=True):
        """
        Maximise return (helper method).

        Helper method to maximise return. This should not be used to optimize
        a portfolio directly.

        Parameters
        ----------
        return_value : bool, optional
            Whether to return the maximum return value. Defaults to True.

        Returns
        -------
        float or OrderedDict
            The maximum return value if return_value is True,
            otherwise the portfolio weights.
        """
        if self.expected_returns is None:
            raise ValueError("no expected returns provided")

        self._objective = objective_functions.portfolio_return(
            self._w, self.expected_returns
        )

        self.add_constraint(lambda w: cp.sum(w) == 1)

        res = self._solve_cvxpy_opt_problem()

        if return_value:
            return -self._opt.value
        else:
            return res

    def max_sharpe(self, risk_free_rate=0.0):
        """
        Maximise the Sharpe Ratio.

        The result is also referred to as the tangency portfolio, as it is the
        portfolio for which the capital market line is tangent to the efficient frontier.

        This is a convex optimization problem after making a certain variable
        substitution. See `Cornuejols and Tutuncu (2006)
        <http://web.math.ku.dk/~rolf/CT_FinOpt.pdf>`_ for more.

        Parameters
        ----------
        risk_free_rate : float, optional
            Risk-free rate of borrowing/lending. Defaults to 0.0.
            The period of the risk-free rate should correspond to the
            frequency of expected returns.

        Returns
        -------
        OrderedDict
            Asset weights for the Sharpe-maximising portfolio.

        Raises
        ------
        ValueError
            If ``risk_free_rate`` is non-numeric.
            If no asset has expected return exceeding the risk-free rate.

        Examples
        --------
        >>> from pypfopt import EfficientFrontier, expected_returns, risk_models
        >>> # mu = expected_returns.mean_historical_return(prices)
        >>> # S = risk_models.sample_cov(prices)
        >>> # ef = EfficientFrontier(mu, S)
        >>> # weights = ef.max_sharpe(risk_free_rate=0.02)
        """
        if not isinstance(risk_free_rate, (int, float)):
            raise ValueError("risk_free_rate should be numeric")

        if max(self.expected_returns) <= risk_free_rate:
            raise ValueError(
                "at least one of the assets must have an expected return exceeding the risk-free rate"
            )

        self._risk_free_rate = risk_free_rate

        # max_sharpe requires us to make a variable transformation.
        # Here we treat w as the transformed variable.
        self._objective = cp.quad_form(self._w, self.cov_matrix, assume_PSD=True)
        k = cp.Variable()

        # Note: objectives are not scaled by k. Hence there are subtle differences
        # between how these objectives work for max_sharpe vs min_volatility
        if len(self._additional_objectives) > 0:
            warnings.warn(
                "max_sharpe transforms the optimization problem so additional objectives may not work as expected."
            )
        for obj in self._additional_objectives:
            self._objective += obj

        new_constraints = []
        # Must rebuild the constraints
        for constr in self._constraints:
            if isinstance(constr, cp.constraints.nonpos.Inequality):
                # Either the first or second item is the expression
                if isinstance(
                    constr.args[0], cp.expressions.constants.constant.Constant
                ):
                    new_constraints.append(constr.args[1] >= constr.args[0] * k)
                else:
                    new_constraints.append(constr.args[0] <= constr.args[1] * k)
            elif isinstance(constr, cp.constraints.zero.Equality):
                new_constraints.append(constr.args[0] == constr.args[1] * k)
            else:
                raise TypeError(
                    "Please check that your constraints are in a suitable format"
                )

        # Transformed max_sharpe convex problem:
        self._constraints = [
            (self.expected_returns - risk_free_rate).T @ self._w == 1,
            cp.sum(self._w) == k,
            k >= 0,
        ] + new_constraints

        self._solve_cvxpy_opt_problem()
        # Inverse-transform
        self.weights = (self._w.value / k.value).round(16) + 0.0
        return self._make_output_weights()

    def max_quadratic_utility(self, risk_aversion=1, market_neutral=False):
        r"""
        Maximise the quadratic utility function.

        The quadratic utility is defined as:

        .. math::

            \max_w w^T \mu - \frac \delta 2 w^T \Sigma w

        Parameters
        ----------
        risk_aversion : float, optional
            Risk aversion parameter (must be greater than 0). Defaults to 1.
        market_neutral : bool, optional
            Whether the portfolio should be market neutral (weights sum to zero).
            Defaults to False. Requires negative lower weight bound.

        Returns
        -------
        OrderedDict
            Asset weights for the maximum-utility portfolio.

        Raises
        ------
        ValueError
            If risk_aversion is not greater than zero.

        Examples
        --------
        >>> from pypfopt import EfficientFrontier, expected_returns, risk_models
        >>> # mu = expected_returns.mean_historical_return(prices)
        >>> # S = risk_models.sample_cov(prices)
        >>> # ef = EfficientFrontier(mu, S)
        >>> # weights = ef.max_quadratic_utility(risk_aversion=2)
        """
        if risk_aversion <= 0:
            raise ValueError("risk aversion coefficient must be greater than zero")

        update_existing_parameter = self.is_parameter_defined("risk_aversion")
        if update_existing_parameter:
            self._validate_market_neutral(market_neutral)
            self.update_parameter_value("risk_aversion", risk_aversion)
        else:
            self._objective = objective_functions.quadratic_utility(
                self._w,
                self.expected_returns,
                self.cov_matrix,
                risk_aversion=risk_aversion,
            )
            for obj in self._additional_objectives:
                self._objective += obj

            self._make_weight_sum_constraint(market_neutral)
        return self._solve_cvxpy_opt_problem()

    def efficient_risk(self, target_volatility, market_neutral=False):
        """
        Maximise return for a target risk.

        The resulting portfolio will have a volatility less than the target
        (but not guaranteed to be equal).

        Parameters
        ----------
        target_volatility : float
            The desired maximum volatility of the resulting portfolio.
        market_neutral : bool, optional
            Whether the portfolio should be market neutral (weights sum to zero).
            Defaults to False. Requires negative lower weight bound.

        Returns
        -------
        OrderedDict
            Asset weights for the efficient risk portfolio.

        Raises
        ------
        ValueError
            If ``target_volatility`` is not a positive float.
            If ``target_volatility`` is below the minimum possible volatility.

        Examples
        --------
        >>> from pypfopt import EfficientFrontier, expected_returns, risk_models
        >>> # mu = expected_returns.mean_historical_return(prices)
        >>> # S = risk_models.sample_cov(prices)
        >>> # ef = EfficientFrontier(mu, S)
        >>> # weights = ef.efficient_risk(target_volatility=0.15)
        """
        if not isinstance(target_volatility, (float, int)) or target_volatility < 0:
            raise ValueError("target_volatility should be a positive float")

        global_min_volatility = np.sqrt(1 / np.sum(np.linalg.pinv(self.cov_matrix)))

        if target_volatility < global_min_volatility:
            raise ValueError(
                "The minimum volatility is {:.3f}. Please use a higher target_volatility".format(
                    global_min_volatility
                )
            )

        update_existing_parameter = self.is_parameter_defined("target_variance")
        if update_existing_parameter:
            self._validate_market_neutral(market_neutral)
            self.update_parameter_value("target_variance", target_volatility**2)
        else:
            self._objective = objective_functions.portfolio_return(
                self._w, self.expected_returns
            )
            variance = objective_functions.portfolio_variance(self._w, self.cov_matrix)

            for obj in self._additional_objectives:
                self._objective += obj

            target_variance = cp.Parameter(
                name="target_variance", value=target_volatility**2, nonneg=True
            )
            self.add_constraint(lambda _: variance <= target_variance)
            self._make_weight_sum_constraint(market_neutral)
        return self._solve_cvxpy_opt_problem()

    def efficient_return(self, target_return, market_neutral=False):
        """
        Minimise volatility for a given target return (Markowitz portfolio).

        Calculate the 'Markowitz portfolio', minimising volatility for a given
        target return.

        Parameters
        ----------
        target_return : float
            The desired return of the resulting portfolio.
        market_neutral : bool, optional
            Whether the portfolio should be market neutral (weights sum to zero).
            Defaults to False. Requires negative lower weight bound.

        Returns
        -------
        OrderedDict
            Asset weights for the Markowitz portfolio.

        Raises
        ------
        ValueError
            If ``target_return`` is not a float.
            If ``target_return`` exceeds the maximum possible return.

        Examples
        --------
        >>> from pypfopt import EfficientFrontier, expected_returns, risk_models
        >>> # mu = expected_returns.mean_historical_return(prices)
        >>> # S = risk_models.sample_cov(prices)
        >>> # ef = EfficientFrontier(mu, S)
        >>> # weights = ef.efficient_return(target_return=0.15)
        """
        if not isinstance(target_return, float):
            raise ValueError("target_return should be a float")
        if not self._max_return_value:
            a = self.deepcopy()
            self._max_return_value = a._max_return()
        if target_return > self._max_return_value:
            raise ValueError(
                "target_return must be lower than the maximum possible return"
            )

        update_existing_parameter = self.is_parameter_defined("target_return")
        if update_existing_parameter:
            self._validate_market_neutral(market_neutral)
            self.update_parameter_value("target_return", target_return)
        else:
            self._objective = objective_functions.portfolio_variance(
                self._w, self.cov_matrix
            )
            ret = objective_functions.portfolio_return(
                self._w, self.expected_returns, negative=False
            )

            for obj in self._additional_objectives:
                self._objective += obj

            target_return_par = cp.Parameter(name="target_return", value=target_return)
            self.add_constraint(lambda _: ret >= target_return_par)
            self._make_weight_sum_constraint(market_neutral)
        return self._solve_cvxpy_opt_problem()

    def portfolio_performance(self, verbose=False, risk_free_rate=0.0):
        """
        Calculate the performance of the optimized portfolio.

        After optimising, calculate (and optionally print) the performance of the
        optimal portfolio. Currently calculates expected return, volatility, and
        the Sharpe ratio.

        Parameters
        ----------
        verbose : bool, optional
            Whether performance should be printed. Defaults to False.
        risk_free_rate : float, optional
            Risk-free rate of borrowing/lending. Defaults to 0.0.
            The period of the risk-free rate should correspond to the
            frequency of expected returns.

        Returns
        -------
        tuple
            A tuple of (expected return, volatility, Sharpe ratio).

        Raises
        ------
        ValueError
            If weights have not been calculated yet.

        Examples
        --------
        >>> from pypfopt import EfficientFrontier, expected_returns, risk_models
        >>> # mu = expected_returns.mean_historical_return(prices)
        >>> # S = risk_models.sample_cov(prices)
        >>> # ef = EfficientFrontier(mu, S)
        >>> # ef.max_sharpe()
        >>> # mu, sigma, sharpe = ef.portfolio_performance(verbose=True)
        """
        if self._risk_free_rate is not None:
            if risk_free_rate != self._risk_free_rate:
                warnings.warn(
                    "The risk_free_rate provided to portfolio_performance is different"
                    " to the one used by max_sharpe. Using the previous value.",
                    UserWarning,
                )
            risk_free_rate = self._risk_free_rate

        return base_optimizer.portfolio_performance(
            self.weights,
            self.expected_returns,
            self.cov_matrix,
            verbose,
            risk_free_rate,
        )

    def _validate_market_neutral(self, market_neutral: bool) -> None:
        """
        Validate market neutral parameter consistency.

        Parameters
        ----------
        market_neutral : bool
            Whether the portfolio should be market neutral.

        Raises
        ------
        InstantiationError
            If market_neutral differs from previously set value.
        """
        if self._market_neutral != market_neutral:
            raise exceptions.InstantiationError(
                "A new instance must be created when changing market_neutral."
            )
